[
  {
    "name": "Hash Tables",
    "id": "hash-tables",
    "category": "Concept",
    "subcategory": "Fundamentals",
    "description": "Data structure using hash functions for fast key-value lookups",
    "aliases": ["hash-table", "hash-map", "dictionary"],
    "difficulty": "basic"
  },
  {
    "name": "Trees",
    "id": "trees",
    "category": "Concept",
    "subcategory": "Fundamentals",
    "description": "Hierarchical data structure with nodes connected by edges",
    "aliases": ["tree", "binary-tree", "tree-structure"],
    "difficulty": "basic"
  },
  {
    "name": "Queues",
    "id": "queues",
    "category": "Concept",
    "subcategory": "Fundamentals",
    "description": "FIFO data structure for sequential processing",
    "aliases": ["queue", "fifo"],
    "difficulty": "basic"
  },
  {
    "name": "Stacks",
    "id": "stacks",
    "category": "Concept",
    "subcategory": "Fundamentals",
    "description": "LIFO data structure for last-in-first-out operations",
    "aliases": ["stack", "lifo"],
    "difficulty": "basic"
  },
  {
    "name": "Linked Lists",
    "id": "linked-lists",
    "category": "Concept",
    "subcategory": "Fundamentals",
    "description": "Linear data structure with nodes containing data and references",
    "aliases": ["linked-list", "list"],
    "difficulty": "basic"
  },
  {
    "name": "Sorting Algorithms",
    "id": "sorting",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Algorithms for ordering elements in a collection",
    "aliases": ["sorting", "sort"],
    "difficulty": "intermediate"
  },
  {
    "name": "Searching Algorithms",
    "id": "searching",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Algorithms for finding elements in data structures",
    "aliases": ["searching", "search"],
    "difficulty": "intermediate"
  },
  {
    "name": "Dynamic Programming",
    "id": "dynamic-programming",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Optimization technique breaking problems into overlapping subproblems",
    "aliases": ["dynamic-programming", "dp", "memoization"],
    "difficulty": "advanced"
  },
  {
    "name": "Greedy Algorithms",
    "id": "greedy-algorithms",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Algorithms making locally optimal choices at each step",
    "aliases": ["greedy", "greedy-algorithm"],
    "difficulty": "intermediate"
  },
  {
    "name": "Mutex",
    "id": "mutex",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Mutual exclusion lock for protecting shared resources",
    "aliases": ["mutex", "mutual-exclusion", "lock"],
    "difficulty": "intermediate"
  },
  {
    "name": "Semaphores",
    "id": "semaphores",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Synchronization primitive for controlling access to resources",
    "aliases": ["semaphore"],
    "difficulty": "intermediate"
  },
  {
    "name": "Deadlock",
    "id": "deadlock",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Situation where processes wait indefinitely for resources",
    "aliases": ["deadlock", "livelock"],
    "difficulty": "intermediate"
  },
  {
    "name": "Race Conditions",
    "id": "race-conditions",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Bugs occurring when timing affects program correctness",
    "aliases": ["race-condition", "data-race"],
    "difficulty": "intermediate"
  },
  {
    "name": "Thread Pools",
    "id": "thread-pools",
    "category": "Concept",
    "subcategory": "Advanced",
    "description": "Collection of worker threads for executing tasks",
    "aliases": ["thread-pool", "worker-pool"],
    "difficulty": "intermediate"
  }
]
